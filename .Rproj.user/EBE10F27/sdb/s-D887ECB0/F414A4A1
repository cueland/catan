{
    "collab_server" : "",
    "contents" : "# start clean\nrm(list = ls())\n# Set working directory\nsetwd(\"~/Documents/\")\n\nrequire(stringr)\nrequire(graphics)\n\n# Function to calculate the two adjacent tiles for a given corner\ncalc_adj <- function(x) {\n  # axial coordinate, horizontal coordinate, and corner numbered 1-6 starting at upper right corner\n  a1 <- matrix(c(1,0,3,1,1,4,0,1,5,-1,0,6,-1,-1,1,0,-1,2), ncol = 3, byrow = T)\n  a2 <- matrix(c(1,1,5,0,1,6,-1,0,1,-1,-1,2,0,-1,3,1,0,4), ncol = 3, byrow = T)\n  y <- matrix(c(x[1], x[2], x[3],\n         x[1:2]+a1[x[3],1:2], a1[x[3],3],\n         x[1:2]+a2[x[3],1:2], a2[x[3],3]),ncol=3,byrow=T)\n  colnames(y) <- c(\"ax\", \"hor\", \"c\")\n  y <- data.frame(y[order(y[,3]),])\n  y$time <- 1:3\n  y$id <- 1\n  y <- reshape(y, idvar = \"id\", timevar = \"time\", direction = \"wide\")\n  y$id <- paste(y[,2:ncol(y)], collapse=\",\")\n  return(y)\n}\n\nplot_polygon <- function(xx,yy,fill,stroke, strokew) {\n  # create the string to draw an SVG polygon with colors and borders\n  # check if xx and yy have same length\n    if(length(xx) != length(yy)) {\n      stop(\"XX and YY are different length vectors\")\n    }\n  # check \n  \n  #create array with xx and yy values\n  x <- paste0(\"<polygon class=\\\"{fill:#\", counter\n}\n\ncalc_adj(c(0,0,4))\n\ngetres <- function(tiles, id) {\n  # parse the id\n  dd <- data.frame(t(matrix(as.integer(str_split(id,\",\")[[1]]), nrow = 3, byrow = F, dimnames = list(c(\"ax\", \"hor\", \"corner\")))))\n  dd <- merge(dd,tiles[c(\"ax\", \"hor\", \"res\", \"value\", \"strength\")], by = c(\"ax\", \"hor\"))\n  res <- c(\"Brick\", \"Ore\", \"Sheep\", \"Wheat\", \"Wood\", \"Desert\")\n  # import port data\n  return(list(id = id,\n              tot_prob = sum(dd$strength),\n              res_count = sum(!is.na(dd$res)),\n              uniq_res = length(unique(dd$res)),\n              res = unique(as.character(dd$res)),\n              res_mat = data.frame(res = res,\n                                   strength = unlist(lapply(res, function(x) sum(dd$strength[dd$res==x]))),\n                                   count = unlist(lapply(res, function(x) sum(dd$res==x))))))\n}\n\nid <- paste(c(-1,-1,2,0,0,4,-1,0,6), collapse=\",\")\n\n# Function to calculate the x,y cartesian coordinates from the hex coords and corner\ncart <- function(ax, hor, corner) {\n  if (corner == 0) {\n    return(c(ax*sqrt(3)-0.5*hor*sqrt(3), 1.5*hor))\n    y <- 2*hor\n  }\n  else {\n    return(c(ax*sqrt(3)-0.5*hor*sqrt(3) + cos(corner*pi/3-pi/6), 1.5*hor+sin(corner*pi/3-pi/6)))\n  }\n}\n\n# function to output an x,y array of coords for the corners of a polygon\ncorns <- function(x) {\n  return(data.frame(xx = (x[1]*sqrt(3)-0.5*x[2]*sqrt(3))+sqrt(3)/2*c(1,0,-1,-1,0,1), yy = 1.5*x[2]+0.5*c(1,2,1,-1,-2,-1)))\n}\n\ncorns(c(0,0))\n\n#function to find x,y of the center of a hex\ncentfind <- function(x) {\n  # x is an array (ax,hor) of the hexagon in question\n  return(c(x[1]*sqrt(3)-0.5*x[2]*sqrt(3), 1.5*x[2]))\n}\n\n#function to find x,y of a corner\ncornfind <- function(x) {\n  # x is an array (ax,hor,corner) of the hexagon corner in question\n  return(c(x[1]*sqrt(3)-0.5*x[2]*sqrt(3)+sqrt(3)/2*x[3], 1.5*x[2]+0.5*x[3]))\n}\n\n# force R to never use scientific notation\n# options(\"scipen\"=100, \"digits\"=4)\n\n# Input the order of number chits and their corresponding strengths\nchits <- data.frame(lett = LETTERS[1:18], value = c(5, 2, 6, 3, 8, 10, 9, 12, 11, 4, 8, 10, 9, 4, 5, 6, 3, 11))\n\n# calculate dice probabilities\nchits$strength <- 6-abs(7-chits$value)\n\n# Randomize the resource types, match with the coordinates(ax, hor) of the spiral sequence\ntiles <- data.frame(tile = c(1:19),\n                    res = sample(rep(c(\"Brick\", \"Ore\", \"Sheep\", \"Wheat\", \"Wood\", \"Desert\"), times=c(3,3,4,4,4,1))),\n                    ax = c(2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 2, 2, 1, 0, -1, -1, 0, 1, 0),\n                    hor = c(2, 2, 2, 1, 0, -1, -2, -2, -2, -1, 0, 1, 1, 1, 0, -1, -1, 0, 0))\n\ntiles$lett[tiles$res != \"Desert\"] <- as.character(chits$lett)\ntiles <- merge(tiles, chits, by = \"lett\", all=T, sort = F)\nrm(chits)\ntiles$strength[tiles$res == \"Desert\"] <- 0\n\n# reorder the tiles in original random order (undone by merge)\ntiles <- tiles[order(tiles$tile), ]\nrow.names(tiles) <- NULL\n\n# define the ports (to randomize, add sample to the port types)\nports <- data.frame(tile.orig = c(1, 2, 3, 3, 4, 4, 6, 6, 7, 7, 8, 8, 10, 10, 11, 11, 12, 12),\n                    corner.orig = c(3, 2, 2, 3, 3, 4, 3, 4, 4, 5, 5, 6, 5, 6, 6, 1, 1, 2),\n                    port = rep(c(\"Sheep\", \"Random\", \"Ore\", \"Wheat\", \"Random\", \"Wood\", \"Brick\", \"Random\", \"Random\"),\n                               times = rep(2,9)))\n\n# randomize the offset for the ports\np_offset <- sample(0:5, 1) # can orient the board 6 different ways\nports$tile <- (ports$tile.orig+2*p_offset-1)%%12+1\nports$corner <- (ports$corner.orig+p_offset-1)%%6+1\n\n# convert tile number to tile coords\nports <- merge(ports, tiles[,c(\"tile\", \"ax\", \"hor\")], by = \"tile\", all.x=T)\n\n# add unique id to each port corner\nports$id <- do.call(rbind, apply(ports[,c(\"ax\", \"hor\", \"corner\")], 1, FUN = calc_adj))$id\n\n# create a data frame to house all the relevant corners of the game\ncorners <- merge(expand.grid(tile = 1:nrow(tiles), corner = 1:6), tiles[,c(\"tile\", \"ax\", \"hor\")], by = \"tile\", all.x = T)\n\n# get relevant corner codes with corner id's, then strip off duplicates\ncornerids <- unique(do.call(rbind, apply(corners[,c(\"ax\", \"hor\", \"corner\")], 1, FUN = calc_adj))$id)\n\n# \ncorners <- data.frame(do.call(rbind, lapply(cornerids, function(x) getres(tiles, x))))\nfor (n in c(\"id\", \"tot_prob\", \"res_count\", \"uniq_res\")) {\n  corners[,n] <- unlist(corners[,n])\n}\n\n# merge in port data\ncorners <- merge(corners, ports[,c(\"id\", \"port\")], by = \"id\", all.x = TRUE)\nrm(ports)\n\n# order decreasing by best prob and then unique resources\ncorners <- corners[order(corners$tot_prob, corners$uniq_res, decreasing=T),]\n\n# calculate x,y position for corners\ncorners1 <- t(apply(t(sapply(str_split(corners$id, \",\"), FUN = as.integer))[,1:3], 1, FUN = cornfind))\ncolnames(corners1) <- c(\"xx\", \"yy\")\ncorners <- cbind(corners, corners1)\nrm(corners1)\n\ncolhx <- data.frame(res = c(\"Brick\", \"Ore\", \"Sheep\", \"Wheat\", \"Wood\", \"Desert\"),\n                    hex = c(\"#945337\", \"#b8a2c7\",\"#c7e0ca\", \"#fff9b9\", \"#7aa86b\", \"#cccccc\"))\ntiles$ord <- 1:nrow(tiles)\ncolss <- merge(tiles, colhx, by = \"res\", all.x= T)\ncolss <- colss[order(colss$ord),]\ncolss$strength[is.na(colss$strength)] <- 0\ncolss$stars <- sapply(colss$strength, function(x){paste0(rep(\"*\",x), collapse=\"\")})\n\ncolss$desc <- as.expression(paste(colss$res, colss$value, colss$stars, sep=\"\\n\"))\nxx <- lapply(colss, function(x){expression(paste(x$res, x$value, x$stars, sep=\"/n\"))})\nx <- split(unlist(lapply(as.list(data.frame(t(tiles[,c(\"ax\", \"hor\")]))), FUN = centfind)), rep(1:2,19))\n\ndat <- lapply(as.list(data.frame(t(tiles[,c(\"ax\", \"hor\")]))), FUN = corns)\ndat <- split(c(dat, as.character(colss$hex)), rep(1:19,2))\n\n\nplot(-5:5,-5:5, type='n')\nlapply(dat, function(x){polygon(x[[1]]$xx, x[[1]]$yy, col = x[[2]], border = \"black\")})\ntext(x[[1]], x[[2]], labels = lapply(colss$desc, function(x) paste0(x)))\n# symbols(corners$xx, corners$yy, circles = rep(1,length(corners$xx)))\n",
    "created" : 1564757035087.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1576702327",
    "id" : "F414A4A1",
    "lastKnownWriteTime" : 1564755316,
    "last_content_update" : 1564755316,
    "path" : "~/Documents/Projects/catan/catan.R",
    "project_path" : "catan.R",
    "properties" : {
        "source_window_id" : "wu68v0dgw7w7i"
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}